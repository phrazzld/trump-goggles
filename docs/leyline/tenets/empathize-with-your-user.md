---
id: empathize-with-your-user
last_modified: '2025-06-09'
version: '0.1.0'
---

# Tenet: Empathize With Your User

Build software with deep understanding of user context, needs, and goals. Engineering excellence is a means to an end—that end is creating value for real people solving real problems. Every technical decision should consider its impact on the human experience.

## Core Belief

Think of the difference between an architect and a construction worker. Both are skilled professionals, but an architect must understand how people will actually live and work in the spaces they design. They consider natural light, traffic flow, accessibility needs, daily routines, and the emotional impact of different design choices. A construction worker focuses on technical execution—ensuring walls are straight, joints are secure, and materials are properly installed according to specifications. Both perspectives are essential, but the architect's user-centered thinking must guide the technical implementation. Without the architect's empathy for human needs, you might have a structurally sound building that's miserable to inhabit.

As software developers, we must be architects first. Our technical decisions—from API design to error handling to performance optimization—should flow from a deep understanding of how users will interact with our software in real-world contexts, not just idealized testing scenarios. When we prioritize technical elegance over user needs, we risk building beautifully crafted software that nobody wants to use or that solves problems in ways that create new frustrations. Engineering excellence without user empathy creates monuments to our cleverness rather than tools that genuinely help people accomplish their goals more effectively.

User empathy manifests in quality attributes that are often invisible to users when done well but painfully obvious when done poorly. Fast loading times, clear error messages, intuitive interfaces, and accessibility features are all expressions of empathy—they represent decisions to prioritize user experience over developer convenience. They demonstrate that we've thought carefully about the human experience and made the extra effort to ensure our software serves people well, not just functions correctly. The best software anticipates user needs and removes friction before users even realize it could exist.

This empathy extends beyond the direct user interface to every technical decision we make. Database performance affects how quickly users can complete tasks. API design determines how easily other developers can integrate with our systems. Error handling affects whether users can recover gracefully from problems or become frustrated and abandon their goals. Even purely internal architectural decisions ultimately impact users through system reliability, maintainability, and the team's ability to respond to changing needs. Every line of code we write either helps users accomplish their goals or gets in their way—there is no neutral ground.

## Practical Guidelines

1. **Understand the User's Goal**: Before writing any code, clearly articulate what users are trying to accomplish and why, going beyond surface-level feature requirements to understand deeper motivations and constraints. Don't just implement features—solve problems that matter to real people in real contexts. Talk to actual users when possible, or at least ensure someone on your team has direct user contact and regularly shares insights with the development team. Understand not just what users want, but what they're really trying to achieve and what obstacles currently prevent them from succeeding. Ask yourself: "What is the user trying to achieve, and how does this feature help them get there faster, with less frustration, or with better outcomes?" Remember that users often ask for specific solutions when what they really need is for you to understand and solve their underlying problem.

2. **Advocate for User Needs in Technical Discussions**: When your team discusses architecture, performance trade-offs, or feature scope, consistently raise the user perspective and ensure user impact is considered alongside technical concerns. Challenge purely technical solutions that ignore user impact, even when those solutions are easier to implement or maintain. Be willing to advocate for additional complexity if it significantly improves the user experience, but also push back on technical complexity that provides no user benefit. Ask yourself: "How will this technical decision affect the people who use our software, both immediately and in the long term?" Be the voice that asks whether a technically convenient solution creates user friction, and be prepared to suggest user-centered alternatives even when they require more development effort.

3. **Design for the 'Unhappy Path'**: Spend as much time designing error states, edge cases, and failure scenarios as you do the main user flow, because these moments of friction often determine whether users succeed or abandon their goals. Users judge software quality by how it behaves when things go wrong, not when everything works perfectly—and things will go wrong more often than you expect. Design error messages that explain what happened in user-friendly language and provide clear next steps for recovery. Consider partial failure modes where some functionality might be degraded but users can still accomplish their core goals. Ask yourself: "When this feature fails or behaves unexpectedly, will users understand what happened, know it's not their fault, and have a clear path to recovery?" Clear, helpful error handling is often the difference between a frustrated user and a loyal one.

4. **Prioritize Accessibility from the Start**: Build software that works for users with disabilities, not as an afterthought but as a core requirement that influences architectural decisions from the beginning. Accessibility improvements often benefit all users, making interfaces clearer, more intuitive, and more resilient to different usage contexts. Consider not just obvious disabilities like blindness or mobility impairments, but also situational disabilities like using software in bright sunlight, on a slow network, or while distracted. Design for keyboard navigation, screen readers, and users who may not use a mouse. Ask yourself: "Can users with visual, motor, or cognitive impairments successfully use this feature?" Consider accessibility early when changes are cheap and architectural, not late when they require expensive retrofitting that often results in compromised solutions.

5. **Use the Product Yourself**: Regularly interact with your software the way your users do, not just as a developer testing functionality but as a real person trying to accomplish meaningful goals. Don't just test that features work—experience them as a user would, including the emotional experience of using your software when you're frustrated, rushed, or learning something new. Try using your software in different contexts: on mobile devices, with slow internet, when distracted, or when you haven't used it for a while. This practice reveals friction points and usability issues that aren't obvious from a developer's perspective and helps you maintain empathy for the user experience. Ask yourself: "When was the last time I used our software to accomplish a real task rather than just verify it works correctly?" Regular dogfooding builds natural empathy and keeps you connected to the human impact of your technical decisions.

6. **Measure and Monitor User Experience**: Implement monitoring and analytics that help you understand how users actually interact with your software, not just whether it's functioning correctly from a technical perspective. Track user success rates, completion times, error rates, and abandonment points to identify where users struggle. Set up alerts for user-facing issues that might not trigger technical monitoring but significantly impact user experience. Use both quantitative data and qualitative feedback to understand the full picture of user experience. Ask yourself: "How do we know whether our software is actually helping users achieve their goals, and how quickly would we know if that changed?" Data-driven empathy helps you make user-centered decisions even when you can't directly observe user behavior.

## Warning Signs

- **Technical-only discussions in planning meetings** where features are discussed primarily in terms of implementation details, technology choices, and system architecture rather than user problems being solved or outcomes being achieved. When you hear more conversation about database schemas, API design, or framework choices than about user workflows, pain points, or success metrics, empathy is being lost in technical complexity. This pattern indicates that the team has become internally focused and is solving technical problems rather than user problems. Such discussions often lead to over-engineered solutions that are technically impressive but miss the mark on user value, or conversely, to technically convenient solutions that create unnecessary user friction.

- **Treating accessibility and internationalization as edge cases or post-launch concerns** rather than core requirements that influence fundamental design decisions indicates a narrow and exclusionary view of who your users are and deserve to be. This mindset suggests the team is unconsciously optimizing for users who look, work, and think exactly like themselves rather than acknowledging the diverse reality of actual user bases. It often manifests as retrofitting accessibility features after core functionality is built, which typically results in clunky, second-class experiences for users with disabilities. Teams with this warning sign often underestimate the market size and business value of inclusive design, missing opportunities to serve broader audiences effectively.

- **Cryptic or technical error messages that require domain knowledge to understand** reveal a fundamental disconnect between developer mental models and user needs, showing that the team is communicating in their own language rather than the user's language. Error messages like "NullPointerException," "HTTP 500," or "Validation failed" are meaningful to developers but completely useless to users trying to accomplish their goals. This pattern extends beyond error messages to include technical jargon in interfaces, documentation written for other developers rather than users, and features that require understanding of the underlying system architecture. Users shouldn't need to understand your technology stack to use your software effectively.

- **Teams working in complete isolation from user feedback** without regular exposure to how their software is actually used in real-world contexts, including the frustrations, workarounds, and unexpected usage patterns that emerge outside of controlled testing environments. When developers never hear user complaints, see user struggles firsthand, or receive direct feedback about the impact of their technical decisions, they inevitably lose touch with the human consequences of their work. This isolation often leads to assumptions about user behavior that prove wrong, features that solve theoretical rather than real problems, and missed opportunities to address actual user pain points. The longer teams work without user contact, the more their empathy atrophies.

- **Performance and feature trade-offs that consistently prioritize internal system convenience over user experience** indicate that technical constraints and developer productivity are driving product decisions rather than user value and business outcomes. This pattern manifests as slow response times that are accepted because they're easier to implement, complex user interfaces that mirror internal data structures rather than user mental models, or forced workarounds that make technical sense but create unnecessary cognitive load for users. While technical constraints are real and must be considered, teams exhibiting this pattern have lost sight of the principle that technology should serve users, not the other way around.

- **User research and feedback being dismissed as "not understanding the technical constraints"** shows that the team has developed an adversarial rather than collaborative relationship with users and user advocates. This pattern often emerges when engineers become defensive about technical decisions and start viewing user needs as obstacles to elegant technical solutions rather than the problems they're trying to solve. Teams exhibiting this warning sign often rationalize poor user experiences by explaining why they're technically necessary, rather than treating user friction as a technical problem to be solved creatively. This mindset prevents the kind of innovative problem-solving that finds technical solutions that serve both user needs and system constraints.

- **Feature requests being evaluated primarily on technical complexity rather than user value** indicates that the development process has become divorced from business and user outcomes. When the primary criteria for prioritizing work is "how hard will this be to build" rather than "how much will this help our users," the team has lost sight of their purpose. This pattern often leads to shipping easy-to-build features that provide little user value while avoiding impactful but challenging user experience improvements. Teams with this anti-pattern often have clean, elegant codebases that power software nobody wants to use.

## Related Tenets

- [Simplicity](simplicity.md): User empathy naturally leads to simpler solutions because complex interfaces and interactions are harder for users to understand, navigate, and recover from when things go wrong. When you truly understand user needs and mental models, you often discover that simpler approaches serve them better than sophisticated but confusing alternatives that may seem impressive from a technical perspective. Empathy reveals that users want to accomplish their goals efficiently and confidently, not admire clever implementation details. The relationship works both ways: pursuing simplicity forces you to understand what users actually need versus what you think they need, while empathy for user cognitive load drives you toward simpler solutions. Complex user interfaces often indicate that the team understands the technology better than they understand their users.

- [Fix Broken Windows](fix-broken-windows.md): User-facing broken windows—confusing interfaces, poor error messages, accessibility issues, or inconsistent behaviors—have immediate and direct impact on user experience and should be prioritized for fixing over purely internal technical debt. Users encounter these problems directly in their daily workflows, making them more urgent than backend code quality issues that users never see. The broken windows theory applies powerfully to user experience: one confusing dialog box or unhelpful error message signals to users that the software doesn't respect their time or intelligence, leading them to expect and tolerate more problems. User empathy helps identify which broken windows matter most by prioritizing issues that actually affect user success and satisfaction rather than just developer convenience.

- [Deliver Value Continuously](deliver-value-continuously.md): Frequent delivery enables faster feedback loops with users, allowing teams to validate whether their empathy assumptions are correct and adjust quickly when they discover gaps between intended and actual user experience. Continuous delivery and user empathy reinforce each other by creating tight feedback cycles that keep teams connected to real user needs rather than theoretical requirements. Without continuous delivery, empathy becomes academic—you might understand user problems but can't respond quickly enough to solve them effectively. Conversely, without user empathy, continuous delivery becomes meaningless technical activity that optimizes for deployment frequency rather than user outcomes. The combination enables rapid experimentation and learning that keeps software aligned with evolving user needs.

- [Testability](testability.md): Building empathy for users requires understanding how they actually use your software, which drives investment in monitoring, analytics, and testing approaches that reveal real user behavior rather than just technical correctness. User-centered testing goes beyond verifying that features work as designed to validating that they solve real user problems effectively. This includes usability testing, accessibility testing, performance testing under real-world conditions, and monitoring user success rates in production. Empathy for users also drives investment in better error handling and recovery mechanisms, which require comprehensive testing of failure scenarios that users might encounter. The relationship is bidirectional: building testable systems makes it easier to validate user experience, while focusing on user outcomes drives better testing practices that reveal problems users actually care about.
