---
id: deliver-value-continuously
last_modified: '2025-06-09'
version: '0.1.0'
---

# Tenet: Deliver Value Continuously

The ultimate measure of success is working software in the hands of users. Prioritize a steady flow of small, valuable deliveries over large, infrequent releases. This approach minimizes risk, accelerates feedback, and ensures our work is always aligned with real-world needs.

## Core Belief

This tenet connects the "how" of our development (our other principles) to the "why" (business and user value). It frames our work not as a series of technical tasks to be completed, but as a continuous process of delivering value. Large, "big bang" releases are inherently risky; they are difficult to test, hard to roll back, and the value they contain is locked away from users for long periods. The traditional model of working in isolation for weeks or months before releasing creates artificial barriers between developers and the people they serve.

Think of continuous delivery like a conversation. A good conversation involves a back-and-forth exchange of small ideas that build upon each other, with each participant responding to what they've heard and building on it. It would be ineffective to save up everything you want to say for a single, hour-long monologue where your audience has no opportunity to respond or clarify. Similarly, delivering software in small pieces creates a conversation with our users, allowing their feedback to shape the product's evolution. Each small delivery teaches us something about what users actually need and want, rather than what we think they need.

By delivering frequently, we transform deployment from a high-stress, high-risk event into a routine, low-risk activity. This shift reduces the anxiety around releases and builds momentum within the team. When deployment becomes routine, we can focus our energy on creating value rather than managing risk. The compound effect of continuous learning and adaptation through frequent releases creates a development velocity that far exceeds what's possible with infrequent, large releases.

The benefits extend beyond just speed—continuous delivery fundamentally changes how teams think about quality and risk management. When releases are small and frequent, problems are easier to isolate, diagnose, and fix. Rollbacks become simple operations rather than complex emergency procedures. Teams develop confidence in their ability to respond to issues quickly, which paradoxically makes them more willing to take appropriate risks and try innovative solutions. This creates a positive feedback loop where higher deployment frequency leads to better practices, which enables even higher frequency.

## Practical Guidelines

1. **Decompose Work into Small, Vertical Slices**: Break features into the smallest complete user value that touches all layers of your system end-to-end, from user interface to database. Each slice should be independently deployable and provide some user benefit, even if limited. Avoid horizontal slicing where you complete entire layers (like "finish all the backend work first"). Instead, think in terms of user journeys—what's the simplest version that allows a user to accomplish something meaningful? Ask yourself: "What's the simplest version of this feature that users could actually use and benefit from?" Resist the temptation to wait until a feature is "complete" before releasing it, as completeness is often an illusion that delays value delivery unnecessarily.

2. **Integrate and Deploy Frequently**: Merge code to the main branch multiple times daily and ensure every merge triggers an automated build, test, and deployment process. This practice catches integration issues early when they're easy and cheap to fix, rather than letting them compound into complex problems. Long-lived feature branches create integration debt that grows exponentially over time. Frequent integration also improves team collaboration by keeping everyone working on the same foundation. Ask yourself: "Could we release the main branch right now with complete confidence?" If the answer is no, identify what's blocking that confidence and address it immediately rather than continuing to build on an unstable foundation.

3. **Decouple Deployment from Release**: Use feature flags, configuration toggles, and runtime switches to separate the technical act of deploying code from the business decision of releasing features to users. This allows you to deploy code safely while controlling when features become available to different user segments. Feature flags enable techniques like canary releases, A/B testing, and gradual rollouts that reduce risk and provide valuable data. They also allow you to respond quickly to issues by turning features off without needing to redeploy. Ask yourself: "Can we turn this feature off without requiring a new deployment?" This capability is essential for safe, frequent delivery and rapid incident response.

4. **Build High-Fidelity Deployment Pipeline**: Invest heavily in making your CI/CD pipeline fast, comprehensive, and reliable—it's the foundation that enables everything else. Your pipeline should give you complete confidence that code passing through it is ready for production. This means comprehensive testing, security scanning, performance validation, and any other quality gates your application requires. A slow or unreliable pipeline becomes a bottleneck that forces teams back into batch-and-queue thinking. Ask yourself: "Does our pipeline catch the kinds of issues that would cause problems in production?" A trustworthy pipeline eliminates the need for manual testing phases and stabilization periods that delay value delivery.

5. **Focus on Cycle Time**: Measure and optimize the time from idea conception to working software in users' hands—this is the ultimate metric of development effectiveness. Cycle time reveals bottlenecks in your development process and drives improvements that benefit the entire team. Track not just coding time, but time spent in code review, testing, deployment, and any approval processes. Long cycle times often indicate systemic issues like over-complex development processes, insufficient automation, or organizational bottlenecks. Ask yourself: "What's the biggest bottleneck preventing us from delivering value faster?" Address these bottlenecks systematically, starting with the constraint that has the highest impact on flow.

6. **Establish Feedback Loops with Users**: Create direct channels for gathering user feedback on delivered features through analytics, user interviews, support tickets, in-app feedback mechanisms, and usage monitoring. Use this feedback to validate that your delivered value actually meets user needs and drives desired outcomes. Fast feedback loops allow you to course-correct quickly when assumptions prove wrong, rather than continuing down ineffective paths. The goal is not just to deliver frequently, but to learn frequently and adapt based on real user behavior rather than speculation. Ask yourself: "How quickly do we learn whether our delivered features solve real user problems?" The faster you learn, the faster you can adapt and deliver even more valuable solutions.

7. **Minimize Work in Progress**: Limit the number of features being developed simultaneously to reduce context switching and accelerate delivery of individual items. When teams work on too many things at once, everything takes longer and quality suffers. Focus on getting fewer things to done rather than starting more things. This applies to individuals, teams, and organizations—the goal is smooth flow of value, not maximum utilization of resources. Ask yourself: "How many different features are we actively working on, and is this number helping or hurting our delivery speed?" Remember that finishing and delivering work creates value, while starting work only creates cost and complexity until it's complete.

## Warning Signs

- **Long-lived feature branches** that exist for weeks or months indicate you're not integrating frequently enough and have fallen back into batch-and-queue thinking. These branches lead to painful merge conflicts, delayed feedback, and increase the risk that the work won't integrate cleanly with the main codebase. They also create knowledge silos where team members become disconnected from each other's work. The longer branches live, the more they diverge, creating exponentially increasing integration risks. When you see branches that require "merge parties" or dedicated integration time, you've lost the benefits of continuous integration and are essentially practicing a form of delayed batch integration.

- **"Release Day" anxiety and special stabilization periods** before releases indicate that releases have become large, risky events rather than routine activities. This anxiety manifests as all-hands meetings, dedicated testing phases, late-night deployments, and management oversight that wouldn't be necessary for routine operations. When you need special preparation and coordination for releases, it means too much change is being bundled together, making it difficult to predict and control the impact. Teams experiencing release anxiety often develop elaborate processes and checkpoints that actually make the problem worse by increasing batch sizes and cycle times.

- **Backlog of completed features waiting for release approval** means valuable functionality is sitting idle instead of reaching users who could benefit from it immediately. This pattern violates the core principle of continuous value delivery and delays the feedback that could improve your product. Features waiting in queues represent sunk cost that isn't generating value or learning. The longer features wait to be released, the more likely they are to become stale or irrelevant by the time users finally see them. This pattern often indicates organizational bottlenecks or approval processes that prioritize risk avoidance over value delivery.

- **Inability to quickly roll back problematic changes** without a full redeployment cycle indicates poor deployment pipeline design and technical architecture choices that block confidence in frequent releases. When rollback is complex, time-consuming, or risky, teams naturally become more conservative about releasing, which reduces delivery frequency and learning velocity. This problem often stems from tightly coupled deployments, database migration dependencies, or insufficient infrastructure automation. The fear of being unable to undo changes creates a vicious cycle where teams batch more changes together to reduce deployment frequency, which makes each deployment riskier and rollbacks even more necessary.

- **Product and engineering teams working in separate, sequential phases** where design happens for months followed by implementation for months prevents the collaborative iteration that leads to better products. This waterfall-style handoff model delays value delivery and reduces the team's ability to adapt based on user feedback or technical discoveries. When product people disappear after the "design phase" and developers work in isolation during the "implementation phase," you lose the collaborative problem-solving that produces innovative solutions. Sequential phases also create artificial constraints where later discoveries can't influence earlier decisions, leading to suboptimal outcomes.

- **Manual testing and deployment processes** that require human intervention for each release create bottlenecks that prevent frequent delivery and introduce opportunities for human error. When releases require coordinated manual steps, documentation handoffs, or specialized knowledge held by specific individuals, you've created a constraint that limits your delivery frequency to human availability and attention. Manual processes are not just slower—they're inherently less reliable and become increasingly error-prone as teams attempt to go faster. The presence of "deployment runbooks" or "release checklists" often indicates insufficient automation.

- **Features designed and built without user feedback loops** indicate that teams are operating on assumptions rather than validated learning. When development proceeds for weeks or months without any user interaction or validation, you're essentially betting that your initial assumptions were correct. This pattern leads to building features that users don't want or that solve problems in ways users find confusing or inappropriate. Without rapid feedback, teams often discover fundamental design flaws only after significant investment, requiring expensive rework or complete feature abandonment. This violates the core principle of continuous learning through continuous delivery.

## Related Tenets

- [Adaptability and Reversibility](adaptability-and-reversibility.md): Continuous delivery directly enables adaptability by making course corrections quick and low-risk, fundamentally changing how teams respond to changing requirements and market conditions. When you can deploy changes rapidly, you can experiment, learn, and adapt much more effectively based on real user feedback rather than speculation. The ability to roll back changes quickly makes decisions more reversible, encouraging teams to take appropriate risks and try innovative solutions. This creates a virtuous cycle where frequent delivery enables rapid learning, which improves adaptability, which makes teams more effective at continuous delivery. Without continuous delivery, adaptability becomes theoretical—you might know what needs to change, but you can't act on that knowledge quickly enough to matter.

- [Automation](automation.md): Effective continuous delivery requires a high degree of automation in testing, building, and deployment processes—manual processes simply cannot keep pace with the delivery frequency that creates business value. Without automation, frequent releases become prohibitively time-consuming and error-prone, forcing teams back into batch-and-queue thinking where releases are infrequent events requiring manual coordination. Automation is not just helpful for continuous delivery—it's absolutely essential for maintaining quality while increasing delivery speed. The relationship is also bidirectional: the need for continuous delivery drives investment in automation, which improves development practices across the entire organization. Teams that prioritize continuous delivery naturally develop sophisticated automation capabilities that benefit all aspects of their development process.

- [Fix Broken Windows](fix-broken-windows.md): A broken deployment pipeline is a critical "broken window" that must be fixed immediately to maintain the flow of value delivery and team confidence in their development process. When the pipeline is unreliable, the entire team loses confidence in continuous delivery, leading to batching and delays that reduce overall effectiveness and create the very problems that continuous delivery is designed to solve. Both tenets demand immediate attention to problems: broken windows theory says that small problems become big problems if left unaddressed, while continuous delivery requires that delivery problems be resolved quickly to maintain flow. A team that tolerates a flaky deployment pipeline will inevitably develop workarounds and manual processes that undermine their ability to deliver value continuously and respond rapidly to changing needs.

- [Testability](testability.md): Comprehensive automated testing is the foundation that makes continuous delivery safe and reliable—without confidence that changes won't break existing functionality, teams cannot deploy frequently. Testable systems enable the rapid feedback loops that make continuous delivery possible, while the pressure to deliver continuously drives investment in better testing practices. This relationship creates a positive feedback loop where the need for frequent delivery improves testing discipline, which enables even more frequent delivery. Teams practicing continuous delivery naturally develop sophisticated testing strategies including unit tests, integration tests, contract tests, and end-to-end tests that provide multiple layers of confidence. The goal is not just to catch bugs, but to catch them as quickly and cheaply as possible in the development process.
